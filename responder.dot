digraph
{
    graph [ranksep=1.0, nodesep=1.0];
    node [shape=rect];

    // title
    labelloc="t";
    label="OTR Responder";

    /* Sending a dhcm message */

    dhcm [label=<transform<sub>dhcm</sub>(proto_ver<sup>&empty;</sup>, msg_type<sup>&empty;</sup>, send_inst<sup>&empty;</sup>, recv_inst<sup>&empty;</sup>, enc_gx<sup>&empty;</sup>, hashed_gx<sup>&empty;</sup>)>];
    dhcm -> send [label=<dhcm<sup>&empty;</sup>>];

    pv [shape=circle, label=<proto_ver>];
    pv -> dhcm [label=<proto_ver<sup>&empty;</sup>>]
    pv -> rvsm;

    mt_dhcm [shape=circle, label=<msg_type>];
    mt_dhcm -> dhcm [label=<msg_type<sup>&empty;</sup>>];

    mt_rvsm [shape=circle, label=<msg_type>];
    mt_rvsm -> rvsm [label=<msg_type<sup>&empty;</sup>>];

    si [shape=circle, label=<send_inst>];
    si -> dhcm [label=<send_inst<sup>&empty;</sup>>];
    si -> rvsm [label=<send_inst<sup>&empty;</sup>>];

    ri [shape=circle, label=<recv_inst>];
    ri -> dhcm [label=<recv_inst<sup>&empty;</sup>>];
    ri -> rvsm [label=<recv_inst<sup>&empty;</sup>>];

    encgx [label=<encrypt((0<sup>{i}</sup>, revealed_key<sup>{c,i,f}</sup>)<sup>{f}</sup>, gxmpi<sup>{c,i}</sup>)>];
    encgx -> dhcm [label=<enc_gx<sup>&empty;</sup>>];

    hashedgx [label=<hash(gxmpi<sup>{i}</sup>)>];
    hashedgx -> dhcm [label=<hashed_gx<sup>&empty;</sup>>];

    iv [shape=circle, label=<0>];
    iv -> encgx [label=<0<sup>{i}</sup>>];

    revealed_key [label=<rand(128<sup>{i}</sup>)>];
    revealed_key -> encgx[label=<revealed_key<sup>{c,i,f}</sup>>];
    revealed_key -> rvsm [label=<revealed_key<sup>&empty;</sup>>];

    bits128 [shape=circle, label=<128>];
    bits128 -> revealed_key [label=<128<sup>{i}</sup>>];

    gxmpi [label=<transform<sub>mpi</sub>(gx<sup>{c,i}</sup>)>]
    gxmpi -> encgx [label=<gxmpi<sup>{c,i}</sup>>];
    gxmpi -> hashedgx [label=<gxmpi<sup>{c,i}</sup>>];
    gxmpi -> min [label=<gxmpi<sup>{c,i}</sup>>];
    gxmpi -> hmac_input [label=<gxmpi<sup>{c,i}</sup>>];

    gx [label=<power(g<sup>{i}</sup>, x<sup>{c,i}</sup>)>]
    gx -> gxmpi [label=<gx<sup>{c,i}</sup>>];

    g [shape=circle, label=<g>];
    g -> gx [label=<g<sup>{i}</sup>>];

    x [label=<rand(320<sup>{i}</sup>)>]
    x -> gx [label=<x<sup>{c,i,f}</sup>>];
    x -> s [label=<x<sup>{c,i,f}</sup>>];

    bits320 [shape=circle, label=<320>];
    bits320 -> x [label=<320<sup>{i}</sup>>];

    /* Receiving a message */
    receive [color=black, style=filled, fontcolor=white, label=<receive>];
    receive -> dhkm [label=<dhkm<sup>&empty;</sup>>];
    receive -> sigm [label=<sigm<sup>&empty;</sup>>];

    /* Receiving a DH Key message */
    dhkm [label=<transform<sub>undhkm</sub>(dhkm<sup>&empty;</sup>)>]
    dhkm -> min [label=<gympi<sup>&empty;</sup>>];
    dhkm -> gy [label=<gympi<sup>&empty;</sup>>];
    dhkm -> hmac_input [label=<gympi<sup>&empty;</sup>>];

    /* Sending a reveal signature message */
    rvsm [label=<transform<sub>dhcm</sub>(proto_ver<sup>&empty;</sup>, msg_type<sup>&empty;</sup>, send_inst<sup>&empty;</sup>, recv_inst<sup>&empty;</sup>, revealed_key<sup>&empty;</sup>, enc_sig<sup>&empty;</sup>, macd_sig<sup>&empty;</sup>)>];
    rvsm -> send [label=<rvsm<sup>&empty;</sup>>];

    encsig [label=<encrypt((0<sup>{i}</sup>, c<sup>{c,i,f}</sup>)<sup>{f}</sup>, X<sub>B</sub><sup>{i}</sup>)>];
    encsig -> rvsm [label=<enc_sig<sup>&empty;</sup>>];

    rvsm_iv [label=<0>, shape=circle];
    rvsm_iv -> encsig [label=<0<sup>{i}</sup>>];

    rvsm_keys [label=<transform<sub>kdf</sub>(s<sup>{c,i,f}</sup>)>];
    rvsm_keys -> encsig [label=<c<sup>{c,i,f}</sup>>];
    rvsm_keys -> mb [label=<m1<sup>{c,i,f}</sup>>];
    rvsm_keys -> validate_mac [label=<m2<sup>{c,i,f}</sup>>];
    rvsm_keys -> decrypt_sig [label=<c<sup>{c,i,f}</sup>>];
    rvsm_keys -> ma [label=<m1<sup>{c,i,f}</sup>>];

    gy [label=<transform<sub>unmpi</sub>(gympi<sup>&empty;</sup>)>]
    gy -> s [label=<gy<sup>&empty;</sup>>];

    s [label=<power(gy<sup>&empty;</sup>, x<sup>{c,i,f}</sup>)>];
    s -> rvsm_keys [label=<s<sup>{c,i,f}</sup>>];

    xb [label=<transform(pub<sub>B</sub><sup>{i}</sup>, keyid<sub>B</sub><sup>{i}</sup>, sig<sub>B</sub><sup>{i}</sup>)>]
    xb -> encsig [label=<X<sub>B</sub><sup>{i}</sup>>];

    rvsmpubb [shape=circle, label=<pub<sub>B</sub>>];
    rvsmpubb -> xb [label=<pub<sub>B</sub><sup>{i}</sup>>];
    rvsmpubb -> min [label=<pub<sub>B</sub><sup>{i}</sup>>];

    rvsmsecb [shape=circle, label=<sec<sub>B</sub>>];
    rvsmsecb -> rvsm_sig [label=<sec<sub>B</sub><sup>{c, i}</sup>>];

    rvsmkeyid [shape=circle, label=<keyid<sub>B</sub>>];
    rvsmkeyid -> xb [label=<keyid<sub>B</sub><sup>{i}</sup>>];
    rvsmkeyid -> min [label=<keyid<sub>B</sub><sup>{i}</sup>>];

    mb [label=<hmac(m1<sup>{c,i}</sup>, M<sub>in</sub><sup>{c,i}</sup>)>];
    mb -> rvsm_sig [label=<M<sub>B</sub><sup>{i}</sup>>];

    min [label=<transform(gxmpi<sup>{c,i}</sup>, gympi<sup>&empty;</sup>, pub<sub>B</sub><sup>{i}</sup>, keyid<sub>B</sub><sup>{i}</sup>)>];
    min -> mb [label=<M<sub>in</sub><sup>{c,i}</sup>>];

    rvsm_sig [label=<sign(sec<sub>B</sub><sup>{c,i}</sup>, M<sub>B</sub><sup>{i}</sup>>];
    rvsm_sig-> xb [label=<sig<sub>B</sub><sup>&empty;</sup>>];

    /* Receiving a signature message */
    sigm [label=<transform<sub>unsigm</sub>(sigm<sup>&empty;</sup>)>];
    sigm -> validate_mac [label=<enc_sig<sup>&empty;</sup>>];
    sigm -> validate_mac [label=<macd_sig<sup>&empty;</sup>>];

    /* check MAC */
    validate_mac [label=<validate_mac(enc_sig<sup>&empty;</sup>, macd_sig<sup>&empty;</sup>, m2<sup>{c,i}</sup>)>];
    validate_mac -> decrypt_sig [label=<enc_sig<sup>{i}</sup>>];

    sigm_iv [label=<0>, shape=circle];
    sigm_iv -> decrypt_sig [label=<0<sup>{i}</sup>>];

    /* signature check */
    decrypt_sig [label=<decrypt(0<sup>{i}</sup>, enc_sig<sup>{i}</sup>, c<sup>{c,i}</sup>)>];

    decrypt_sig -> hmac_input [label=<pub<sub>A</sub><sup>{i}</sup>>];
    decrypt_sig -> hmac_input [label=<keyid<sub>A</sub><sup>{i}</sup>>];
    decrypt_sig -> verify [label=<sig<sub>A</sub><sup>{i}</sup>>];
    decrypt_sig -> verify [label=<pub<sub>A</sub><sup>{i}</sup>>];

    /* hmac */
    hmac_input [label=<transform<sub>cat</sub>(gympi<sup>&empty;</sup>, gxmpi<sup>{i}</sup>, pub<sub>A</sub><sup>{i}</sup>, keyid<sub>{i}</sub>)>];
    hmac_input -> ma [label=<hmac_input<sup>{i}</sup>>];

    ma [label=<hmac(m1<sup>{c,i}</sup>, hmac_input<sup>{i}</sup>)>];
    ma -> verify [label=<M<sub>A</sub><sub>{i}</sub>>];

    verify [label=<verify(pub<sub>A</sub><sup>{i}</sup>, M<sub>A</sub><sup>{i}</sup>, sig<sub>A</sub><sup>{i}</sup>)>];
    verify -> enc [label=<sig_ok<sup>{i}</sup>>];

    /* sending a message */
    send [color=black, style=filled, fontcolor=white, label=<send>];
}
